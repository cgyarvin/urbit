1: Nock Made Stupid

WTF?  What is this Nock thing?  Why do you have to learn it?

Nock is a virtual machine, like the Java VM or Microsoft CLR.
Just as you execute Java by compiling it to the JVM, you execute
Watt by compiling it to Nock.  

Do you need to know Nock to learn in Watt?  In theory, no, just
as you don't need to know anything about the JVM to learn Java.
Indeed, in theory we could compile Watt to the JVM (or Java to
Nock).  What's the difference between Nock and the JVM, anyway?
Why do we need a new virtual machine?

There is no formal difference between Nock and the JVM.  Both are
Turing-complete computers.  In practice, they have just about
nothing in common.

The main practical difference is that Nock is about 100 times as
simple as the JVM.  The Nock spec is less than 200 words; it
gzips to 372 bytes.

Why does size matter?  The goal of any programming language is to
become a standard.  The simpler a specification is, the easier to
standardize.  Nock is a practical interpreter as simple as the
most frozen and fundamental of protocols or formats: IPv4, XML,
JSON.  No standards process or organization should be needed to
freeze a 200-word spec.

Since every program in Watt (including the Watt compiler) reduces
to Nock, every program in Watt inherits this precision.  If two
Nock interpreters produce different results, one is wrong, and
it is always easy to tell which - without a "standards lawyer."

Nearly as important is a second difference between Nock and the
JVM, which is that the JVM can call Unix system calls and
libraries, and Nock can't.  Nock has no "native methods" or
foreign-function interface.  Nor is it ever extended,
embellished, forked, improved or advanced.

Java began as a portable language; so did C.  All Java today is
server-side Java, dependent no less than C on library and OS
configuration.  It is possible to write portable Java; it is
possible to write portable C.  It is not possible to write
unportable Nock or Watt.  It is also not possible to write
insecure Nock or Watt, unless your interpreter is so broken
there's an actual hole in it.

(How does Nock obtain native performance, if it can't call out to
C?  How does it print "hello, world," if it can't call a print
function?  Patience, grasshopper.  All will be revealed.)

These are all reasons to _use_ Nock.  But they're not reasons to
_learn_ Nock.  Like JVM bytecode, Nock is as inscrutable as
assembly language.  In fact, you can think of it as a sort of
"functional assembly language."  There are sometimes reasons to
program in real assembly language; there is never a reason to
program in Nock.  Except to learn Nock.

It is not necessary for the Watt programmer to learn Nock.  We
recommend it strongly, however, because Watt has a very special
relationship with Nock - not unlike the relationship between C
and assembly language.  Just as C is a very shallow layer over
the raw CPU, Watt is a very shallow layer over raw Nock - often
little more than a macro.  If you try to learn C without
understanding the CPU under it, you will be forever bemused by
why it works the way it does.  The same is true of Watt and Nock.

So let's learn Nock!  But which Nock?  Nock, though more frozen
than Walt Disney, does have versions.  Nock versions are measured
by integer degrees Kelvin, newer being colder.  The newest is
Nock 6K - roughly the temperature of Neptune.  No change is
anticipated between 6K and absolute zero, though you never know.

The 197-word Nock spec contains no non-normative text and is
strictly for hardcore supergeeks.  We have verified that hardcore
supergeeks can write correct implementations from this spec
alone.  If you're a hardcore supergeek, you might want to stop
right here and write your own Nock implementation, followed by
the standard exercise - a Nock decrement program.  If not, keep
reading.

To make Nock make sense, let's work through Nock 6K line by line.
First the data model (lines 1-4):

  1 Structures

    A noun is an atom or a cell.  An atom is any natural number.
    A cell is any ordered pair of nouns.

Nouns are the stupidest data model ever.  Nouns make JSON look
like XML and XML look like ASN.1.  It may also remind you of
Lisp's S-expressions - you can think of nouns as "S-expressions
without the S."

To be exact, a noun _is_ an S-expression, except that classic
S-expressions have multiple atom types ("S" is for "symbol").
Since Nock is designed to be used with a higher-level type system
(such as Watt's), it does not need low-level types.  An atom is
just an unsigned integer of any size.

For instance, it's common to represent strings (or even whole
text files) as atoms, arranging them LSB first - so "foo" becomes
0x6f6f66.  How do we know to print this as "foo", not "0x6f6f66"?
We need external information - such as a Watt type.  Similarly,
other common atomic types - signed integers, floating point, etc
- are all straightforward to map into atoms.

It's also important to note that, unlike Lisp, Nock cannot create
cyclical data structures.  It is normal and common for nouns in a
Nock runtime system to have acyclic structure - shared subtrees.
But there is no Nock computation that can make a child point to
its parent.  One consequence: Nock has no garbage collector.
(Nor can acyclic structure be detected, as with Lisp `eq`.)

There is also no single syntax for nouns.  If you have nouns you
have Nock; if you have Nock you have Watt; if you have Watt, you
can write whatever parser you like.

Let's continue (line 6):

  2 Pseudocode

It's important to recognize that the pseudocode of the Nock spec
is just that: pseudocode.  It looks a little like Watt.  It isn't
Watt - it's just pseudocode.  Or in other words, just English.
At the bottom of every formal system is a system of axioms, which
can only be written in English.  Why pseudocode, not Watt?  Since
Watt is defined in Nock, this would only give a false impression
of nonexistent precision.

The logic of this pseudocode is a pattern-matching reduction,
matching from the top down.  To compute Nock, repeatedly reduce
with the first line that matches.

Line 8:

    [a b c]           [a [b c]]

Ie, brackets (in our pseudocode, as in Watt) associate to the
right.  For those with Lisp experience, it's important to note
that Nock and Watt use tuples or "improper lists" much more
heavily than Lisp.  The list terminator, normally 0, is never 
automatic.  So the Lisp list 

    (a b c)

becomes the Nock noun

    [a b c 0]

which is equivalent to

    [a [b [c 0]]]

Note that we can and do use unnecessary brackets anyway, for
emphasis.  Line 9:

    nock(a)           *a

Nock is a pure (stateless) function from noun to noun.  In our
pseudocode (and only in our pseudocode) we express this with the
prefix operator `*`.

This function is defined for every noun, but on many nouns it
does nothing useful.  For instance, if `a` is an atom, `*a`
reduces to... `*a`.  In theory, this means that Nock spins
forever in an infinite loop.  In other words, Nock produces no
result - and in practice, your interpreter will stop.

Another way to see this is that Nock has "crash-only" semantics.
There is no exception mechanism.  The only way to catch Nock
errors is to simulate Nock in a higher-level virtual Nock -
which, in fact, we do all the time.  A simulator (or a practical
low-level interpreter) can report, out of band, that Nock would
not terminate.  It cannot recognize all infinite loops, of
course, but it can catch the obvious ones - like `*42`.

Let's move on to the axiomatic functions.  Lines 11-15:

    ?[a b]            0
    ?a                1
    ^a                1 + a
    =[a a]            0
    =[a b]            1

Here we define more pseudocode operators, which we'll use in
reductions further down.  So far we have four built-in functions:
`*` meaning Nock itself, `?` testing whether a noun is a cell or
an atom, `^` incrementing an atom, and `=` testing for equality.
Again, no rocket science here.

We should note that in Nock and Watt, 0 (pronounced "yes") is
true, and 1 ("no") is false.  Why?  It's fresh, it's different,
it's new.  And it's annoying.  But it keeps you on your toes.

Slightly more interesting is our tree numbering.  Lines 17-21:

    /[1 a]            a
    /[2 a b]          a
    /[3 a b]          b
    /[(a + a) b]      /[2 /[a b]]
    /[(a + a + 1) b]  /[3 /[a b]]

Every noun is of course a tree.  The `/` operator - pronounced
"slot" - imposes an address space on that tree, mapping every
nonzero atom to a tree position.

1 is the root.  The head of every node `n` is `2n`; the tail is
`2n+1`.  Thus a simple tree:

         1
      2      3
    4   5  6   7
             14 15

If the value of every leaf is its tree address, this tree is

    [[4 5] [6 14 15]]

and, for an example of addressing,

    /[7 [[4 5] [6 14 15]]]

is 

    [14 15]

I do hope this isn't so terribly hard to follow.  Line 23:

    *[a [b c] d]      [*[a b c] *[a d]]

This may be the trickiest line in the spec.

Since Nock of an atom just crashes, the practical domain of the
Nock function is always a cell.  Conventionally, the head of this
cell is the "subject," the tail is the "formula," and the result
of Nocking it is the "product."  Basically, the subject is your
data and the formula is your code.

We could write line 23 less formally:

      *[subject [formula-x formula-y]]
  =>  [*[subject formula-x] *[subject formula-y]]

In other words, if you have two Nock formulas `x` and `y`, a
formula that computes the pair of them is just `[x y]`.  We can 
recognize this because no atom is a valid formula, and
every formula that _does not_ use line 23 has an atomic head.

If you know Lisp, you can think of this feature as a sort of
"implicit cons."  Where in Lisp you would write `(cons x y)`,
in Nock you write `[x y]`.

For example,

    *[42 [4 0 1]]

where `42` is the subject (data) and `[4 0 1]` is the formula
(code), happens to evaluate to `43`.  Whereas

    *[42 [3 0 1]]

is `1`.  So if we evaluate

    *[42 [[4 0 1] [3 0 1]]]

we get

    [43 1]

Perhaps this is a good time to fire up the Watt interpreter,
`eyre`, and test this in practice.  Watt is not Nock, of course,
but it has a Nock syntax.  To test Nock expressions in Watt,
instead of 

    *[subject formula]

write 

    .*(subject formula)

So if you run 

  $ eyre 256 hume

and type, at the `:` prompt, 

  : .*(42 [[4 0 1] [3 0 1]])

you should see

  [43 1]

which is all the Watt you need to know right now.  Line 25:

    *[a 0 b]          /[b a]

`0` is simply Nock's tree-addressing operator.  For example, to
reuse our slot example, 

  : .*([[4 5] [6 14 15]] [0 7])

gives, while the sky remains blue and the sun rises in the east:

  [14 15]

Even stupider is line 26:

    *[a 1 b]          b

`1` is the constant operator.  It produces its argument without
reference to the subject.  So

  : .*(42 [1 153 218])

yields

  [153 218]

Line 27 brings us the essential magic of recursion:

    *[a 2 b c]        *[*[a b] *[a c]]

`2` is the Nock operator.  If you can compute a subject and a
formula, you can evaluate them in the interpreter.  In most
fundamental languages, like Lisp, `eval` is a curiosity.  But
Nock has no `apply` - so all our work gets done with `2`.

Let's convert the previous example into a stupid use of `2`:

  : .*(77 [2 [1 42] [1 1 153 218]])

with a constant subject and a constant formula, gives the same

  [153 218]

In lines 28-30, we meet our axiomatic functions again:

    *[a 3 b]          ?*[a b]
    *[a 4 b]          ^*[a b]
    *[a 5 b]          =*[a b]

For instance, if `x` is a formula that calculates some product,
`[4 x]` calculates that product plus one.  Hence:

  : .*(57 [0 1])
  57

and

  : .*([132 19] [0 3])
  19

and

  : .*(57 [4 0 1])
  58

and 

  : .*([132 19] [4 0 3])
  20

If this seems obvious, you're doin' good.

Except for the crash defaults (lines 39-42), we've actually
completed all the _essential_ aspects of Nock.  The operators up
through 5 provide all necessary computational functionality.
Nock, though very simple, is actually much more complex than it
formally needs to be.

Operators 6 through 10 are macros.  They exist because Nock is
not a toy, but a practical interpreter.  Let's see them all
together (lines 32-37):

    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]
    *[a 7 b c]        *[a 2 b 1 c]
    *[a 8 b c]        *[a 7 [[0 1] b] c]
    *[a 9 b c]        *[a 7 c 0 b]
    *[a 10 b c]       *[a c]
    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]

Whoa!  Have we entered rocket-science territory?  Let's try to
figure out what these strange formulas do - simplest first.
The simplest is clearly line 36:

    *[a 10 b c]       *[a c]

If `x` is an atom and `y` is a formula, the formula `[10 x y]` 
appears to be equivalent to... `y`.  For instance:

  : .*([132 19] [10 37 [4 0 3]])
  20

Why would we want to do this?  `10` is actually a hint operator.
The `37` in this example is discarded information - it is not
used, formally, in the computation.  It may help the interpreter
compute the expression more efficiently, however.

Every Nock computes the same result - but not all at the same
speed.  What hints are supported?  What do they do?  Hints are a
higher-level convention which do not, and should not, appear in
the Nock spec.  Some are defined in Watt.  Indeed, a naive Nock
interpreter not optimized for Watt will run Watt quite poorly.
When it gets the product, however, the product will be right.

There is another reduction for hints - line 37:

    *[a 10 [b c] d]   *[a 8 c 7 [0 3] d]

Once we see what `7` and `8` do, we'll see that this complex hint
throws away an arbitrary `b`, but computes the formula `c`
against the subject and... throws away the product.  This formula
is simply equivalent to `d`.  Of course, in practice the product
of `c` will be put to some sordid and practical use.

(Why do we even care that `c` is computed?  Because `c` could
crash.  A correct Nock cannot simply ignore it, and treat both
variants of `10` as equivalent.)

We move on to the next simplest operator, `7`.  Line 33:

    *[a 7 b c]        *[a 2 b 1 c]

Suppose we have two formulas, `b` and `c`.  What is the formula 
`[7 b c]`?  This example will show you:

  : .*(42 [7 [4 0 1] [4 0 1]])
  44

`7` is an old mathematical friend, function composition.  It's
easy to see how this is built out of `2`.  The data to evaluate
is simply `b`, and the formula is `c` quoted.

Line 34 looks very similar:

    *[a 8 b c]        *[a 7 [[0 1] b] c]

Indeed, `8` is `7`, except that the subject for `c` is not simply
the product of `b`, but the ordered pair of the original subject
and the product of `b`.  Hence:

  : .*(42 [8 [4 0 1] [0 1]])
  [42 43]

and 

  : .*(42 [8 [4 0 1] [4 0 3]])
  44

Why would we want to do this?  Imagine a higher-level language
in which the programmer declares a variable.  This language is
likely to generate an `8`, because the variable is computed
against the present subject, and used in a calculation which
depends both on the original subject and the new variable.

Another simple macro is line 35:

    *[a 9 b c]        *[a 7 c 0 b]

`9` is a calling convention.  With `c`, we produce a noun which
contains both code and data - a _core_.  We use this core as the
subject, and apply the formula within it at slot `b`.

It hardly seems worth assigning an operator number for this
simple macro.  But it is, because calls are common and need to be
fast.  We don't want to waste any time recognizing them.

And finally, we come to the piece de resistance - line 32:

    *[a 6 b c d]      *[a 2 [0 1] 2 [1 c d] [1 0] 2 [1 2 3] [1 0] 4 4 b]

Great giblets!  WTF is this doing?  It seems we've finally
arrived at some real rocket science.

Actually, `6` is a primitive known to every programmer - good old
"if."  If `b` evaluates to `0`, we produce `c`; if `b` evaluates
to `1`, we produce `d`; otherwise, we crash.

For instance:

  : .*(42 [6 [1 0] [4 0 1] [1 233]])
  43

and

  : .*(42 [6 [1 1] [4 0 1] [1 233]])
  233

In real life, of course, the Nock implementor knows that `6` is
"if" and implements it as such.  There is no practical sense in
reducing through this macro, or any of the others.  We could have
defined "if" as a built-in function, like increment - except that
we can write "if" as a macro.  If a funky macro. 

It's a good exercise, however, to peek inside the funk.

We can actually simplify the semantics of `6`, at the expense of
breaking the system a little, by creating a macro that works as
"if" only if `b` is a proper boolean and produces `0` or `1`.
Perhaps we have a higher-level type system which checks this.

This simpler "if" would be:

    *[a 6 b c d]    *[a [2 [0 1] [2 [1 c d] [[1 0] [4 4 b]]]]]

Or without so many unnecessary brackets:

    *[a 6 b c d]    *[a 2 [0 1] 2 [1 c d] [1 0] [4 4 b]]

How does this work?  We've replaced `[6 b c d]` with the formula
`[2 [0 1] [2 [1 c d] [[1 0] [4 4 b]]]]`.  We see two uses of `2`,
our evaluation operator - an outer and an inner.

Call the inner one `i`.  So we have `[2 [0 1] i]`.  Which means
that, to calculate our product, we use `[0 1]` - that is, the
original subject - as the subject; and the product of `i` as
the formula.

Okay, cool.  So `i` is `[2 [1 c d] [[1 0] [4 4 b]]]`.  We compute 
Nock with subject `[1 c d]`, formula `[[1 0] [4 4 b]]`.

Obviously, `[1 c d]` produces just `[c d]` - that is, the ordered
pair of the "then" and "else" formulas.  `[[1 0] [4 4 b]]` is a
line 23 cell - its head is `[1 0]`, producing just `0`, its tail
`[4 4 b]`, producing... what?  Well, if `[4 b]` is `b` plus `1`,
`[4 4 b]` is `b` plus `2`.

We're assuming that `b` produces either `0` or `1`.  So `[4 4 b]`
yields either `2` or `3`.  `[[1 0] [4 4 b]]` is either `[0 2]` or
`[0 3]`.  Applied to the subject `[c d]`, this gives us either
`c` or `d` - the product of our inner evaluation `i`.  This is
applied to the original subject, and the result is "if."

But we need the full power of the funk, because if `b` produces,
say, `7`, all kinds of weirdness will result.  We'd really like
`6` to just crash if the test product is not a boolean.  How can
we accomplish this?  This is an excellent way to prove to
yourself that you understand Nock: figure out what the real `6`
does.  Or you could just agree that `6` is "if," and move on.

(It's worth noting that in real, generated Nock, we never do
anything this funky.  There's no reason we couldn't build
formulas at runtime, but we have no reason to and we don't. 
They are always constants resolved through tree addressing.)
