!:
::          %lunt, encryption and protocol.  This file is in the public domain.
::
=>
  |%
  ++  fo                                                ::  modulo prime
    |_  a=@
    ++  dif
      |=  [b=@ c=@]
      (sit (sub (add a b) c))
    ::
    ++  exp
      |=  [b=@ c=@]
      ?:  =(0 b)
        1
      =+  d=$(b (rsh 0 1 b))
      =+  e=(pro d d)
      ?:(=(0 (end 0 1 b)) e (pro c e))
    ::
    ++  fra
      |=  [b=@ c=@]
      (pro b (inv c))
    ::
    ++  inv
      |=  b=@
      =+  c=(dul:si u:(egcd b a) a)
      c
    ::
    ++  pro
      |=  [b=@ c=@]
      (sit (mul b c))
    ::
    ++  sit
      |=  b=@
      (mod b a)
    ::
    ++  sum
      |=  [b=@ c=@]
      (sit (add b c))
    --
  ::
  ++  fu                                                ::  modulo (mul p q)
    |=  a=[p=@ q=@]
    =+  b=(~(inv fo p.a) (~(sit fo p.a) q.a))
    |%
    ++  dif
      |=  [c=[@ @] d=[@ @]]
      [(~(dif fo p.a) -.c -.d) (~(dif fo q.a) +.c +.d)]
    ::
    ++  exp
      |=  [c=@ d=[@ @]]
      :-  (~(exp fo p.a) (mod c (dec p.a)) -.d) 
      (~(exp fo q.a) (mod c (dec q.a)) +.d)
    ::
    ++  out                                             ::  garner's formula
      |=  c=[@ @]
      %+  add
        +.c
      (mul q.a (~(pro fo p.a) b (~(dif fo p.a) -.c (~(sit fo p.a) +.c))))
    ::
    ++  pro
      |=  [c=[@ @] d=[@ @]]
      [(~(pro fo p.a) -.c -.d) (~(pro fo q.a) +.c +.d)]
    ::
    ++  sum
      |=  [c=[@ @] d=[@ @]]
      [(~(sum fo p.a) -.c -.d) (~(sum fo q.a) +.c +.d)]
    ::
    ++  sit
      |=  c=@
      [(mod c p.a) (mod c q.a)]
    --
  ::::
  ::
  ++  egcd                                              ::  schneier's egcd
    |=  [a=@ b=@]
    =+  si
    =+  [c=(sun a) d=(sun b)]
    =+  [u=[c=(sun 1) d=--0] v=[c=--0 d=(sun 1)]]
    |-  ^-  [d=@ u=@ v=@]
    ?:  =(--0 c) 
      [(abs d) d.u d.v]
    ::  ?>  ?&  =(c (sum (pro (sun a) c.u) (pro (sun b) c.v)))
    ::          =(d (sum (pro (sun a) d.u) (pro (sun b) d.v)))
    ::      == 
    =+  q=(fra d c) 
    %=  $
      c  (dif d (pro q c))
      d  c
      u  [(dif d.u (pro q c.u)) c.u]
      v  [(dif d.v (pro q c.v)) c.v]
    ==
  --
=>
  |%
  ++  og                                                ::  shax-powered rng
    |_  a=@
    ++  rad                                             ::  random in range
      |=  b=@  ^-  @
      =+  c=(raw (met 0 b)) 
      ?:((lth c b) c $(a +(a)))
    ::
    ++  raw                                             ::  random bits
      |=  b=@  ^-  @
      %+  can
        0
      =+  c=(shas %og-a (mix b a))
      |-  ^-  (list ,[@ @])
      ?:  =(0 b)
        ~
      =+  d=(shas %og-b (mix b (mix a c)))
      ?:  (lte b 256)
        [[b (end 0 b d)] ~]
      [[256 d] $(c d, b (sub b 256))]
    --
  ::::
  ::
  ++  shad  |=(ruz=@ (shax (shax ruz)))                 ::  double sha-256
  ++  shaf                                              ::  half sha-256
    |=  [sal=@ ruz=@]
    =+  haz=(shas sal ruz)
    (mix (end 7 1 haz) (rsh 7 1 haz))
  ::
  ++  sham                                              ::  noun hash
    |=  yux=*  ^-  @uvI  ^-  @
    ?@  yux
      (shax yux)
    (mix (dec (lsh 8 1 1)) (jam yux))
  ::
  ++  shas                                              ::  salted hash
    |=  [sal=@ ruz=@] 
    (shax (mix sal (shax ruz)))
  ::
  ++  shaw                                              ::  hash to nbits
    |=  [sal=@ len=@ ruz=@]
    (~(raw og (shas sal (mix len ruz))) len)
  --
=>
  |%
  ++  pram                                              ::  r-m primality
    |=  a=@  ^-  ?
    ?:  ?|  =(0 (end 0 1 a))
            =(1 a)
            =+  b=1
            |-  ^-  ?
            ?:  =(512 b)
              |
            ?|(=+(c=+((mul 2 b)) &(!=(a c) =(a (mul c (div a c))))) $(b +(b)))
        ==
      |
    =+  ^=  b
        =+  [s=(dec a) t=0]
        |-  ^-  [s=@ t=@]
        ?:  =(0 (end 0 1 s))
          $(s (rsh 0 1 s), t +(t))
        [s t]
    ?>  =((mul s.b (bex t.b)) (dec a))
    =+  c=0
    |-  ^-  ?
    ?:  =(c 64)
      &
    =+  d=(~(raw og (add c a)) (met 0 a))
    =+  e=(~(exp fo a) s.b d)
    ?&  ?|  =(1 e)
            =+  f=0
            |-  ^-  ?
            ?:  =(e (dec a))
              &
            ?:  =(f (dec t.b))
              |
            $(e (~(pro fo a) e e), f +(f))
        ==
        $(c +(c))
    ==
  ++  ramp                                            ::  make r-m prime
    |=  [a=@ b=(list ,@) c=@]  ^-  @ux                ::  [bits snags seed]
    =>  .(c (shas %ramp c))
    =+  d=@
    |-
    ?:  =((mul 100 a) d)
      ~|(%ar-ramp !!)
    =+  e=(~(raw og c) a)
    ?:  &(|-(?~(b & &(!=(1 (mod e i.b)) $(b +.b)))) (pram e))
      e
    $(c +(c), d (shax d))
  --
=>
  |%
  ++  ac  $_                                            ::  asym cryptosuite
    ^?  |%                                              ::  opaque object
    ++  de  |+([a=@ b=@] *(unit ,@))                    ::  symmetric de, soft
    ++  dy  |+([a=@ b=@] @)                             ::  symmetric de, hard
    ++  en  |+([a=@ b=@] @)                             ::  symmetric en
    ++  es  |+(a=@ @)                                   ::  step key to next
    ++  ex  ^?                                          ::  export
      |%  ++  fig  @uvH                                 ::  fingerprint
          ++  pub  *pass                                ::  public key
          ++  sec  *ring                                ::  private key
      --                                                ::
    ++  mx  @                                           ::  max direct bytes
    ++  nu  ^?                                          ::  reconstructors
      |%  ++  pit  |=([a=@ b=@] ^?(..nu))               ::  from [width seed]
          ++  nol  |=(a=@ ^?(..nu))                     ::  from naked ring
          ++  com  |=(a=@ ^?(..nu))                     ::  from naked pass
      --                                                ::
    ++  pu  ^?                                          ::  public-key acts
      |%  ++  seal  |=([a=@ b=@] [p=@ q=@])             ::  encrypt
          ++  sure  |=(a=@ *(unit ,@))                  ::  authenticate
      --                                                ::
    ++  se  ^?                                          ::  secret-key acts
      |%  ++  sign  |=(a=@ @)                           ::  certify
          ++  tear  |=(a=@ *(unit ,[p=@ q=@]))          ::  accept
      --
    --
  ::::
  ::
  ++  crya                                              ::  cryptosuite A (RSA)
    ^-  ac
    =+  [mos=@ pon=*(unit ,[p=@ q=@ r=[p=@ q=@] s=_*fu])]
    =>  |%
        ++  dap                                         ::  OEAP decode
          |=  [wid=@ xar=@ dog=@]  ^-  [p=@ q=@]
          =+  pav=(sub wid xar)
          =+  qoy=(cut 0 [xar pav] dog)
          =+  dez=(mix (end 0 xar dog) (shaw %pad-b xar qoy))
          [dez (mix qoy (shaw %pad-a pav dez))]
        ::
        ++  pad                                         ::  OEAP encode
          |=  [wid=@ rax=[p=@ q=@] meg=@]  ^-  @
          =+  pav=(sub wid p.rax)
          ?>  (gte pav (met 0 meg))
          ^-  @
          =+  qoy=(mix meg (shaw %pad-a pav q.rax))
          =+  dez=(mix q.rax (shaw %pad-b p.rax qoy))
          (can 0 [p.rax dez] [pav qoy] ~)
        ::
        ++  pull  |=(a=@ (~(exp fo mos) 3 a))
        ++  push  |=(a=@ (~(exp fo mos) 5 a))
        ++  pump
          |=  a=@  ^-  @
          ?~  pon  !!
          (out.s.u.pon (exp.s.u.pon p.r.u.pon (sit.s.u.pon a)))
        ::
        ++  punt
          |=  a=@  ^-  @
          ?~  pon  !!
          (out.s.u.pon (exp.s.u.pon q.r.u.pon (sit.s.u.pon a)))
        --
    |%
    ++  de  
      |+  [key=@ cep=@]  ^-  (unit ,@)
      =+  toh=(met 8 cep)
      ?:  (lth toh 2)
        ~
      =+  adj=(dec toh)
      =+  [hax=(end 8 1 cep) bod=(rsh 8 1 cep)]
      =+  msg=(mix (~(raw og (mix hax key)) (mul 256 adj)) bod)
      ?.  =(hax (shax (mix key (shax (mix adj msg)))))
        ~
      [~ msg]
    ::
    ++  dy  |+([a=@ b=@] (need (de a b)))
    ++  en
      |+  [key=@ msg=@]  ^-  @ux
      =+  len=(met 8 msg)
      =+  adj=?:(=(0 len) 1 len)
      =+  hax=(shax (mix key (shax (mix adj msg))))
      (rap 8 hax (mix msg (~(raw og (mix hax key)) (mul 256 adj))) ~)
    ::
    ++  es  |+(a=@ (shas %anex a))
    ++  ex  ^?
      |%  ++  fig  ^-  @uvH  (shaf %afig mos)
          ++  pub  ^-  pass  (cat 3 'a' mos)
          ++  sec  ^-  ring  ?~(pon !! (cat 3 'A' (jam p.u.pon q.u.pon)))
      --
    ::
    ++  mx  (dec (met 0 mos))
    ++  nu  
      =>  |%
          ++  elcm
            |=  [a=@ b=@]
            (div (mul a b) d:(egcd a b))
          ::
          ++  eldm
            |=  [a=@ b=@ c=@]
            (~(inv fo (elcm (dec b) (dec c))) a)
          ::
          ++  ersa
            |=  [a=@ b=@]
            [a b [(eldm 3 a b) (eldm 5 a b)] (fu a b)]
          --
      ^?
      |%  ++  com
            |=  a=@
            ^+  ^?(..nu)
            ..nu(mos a, pon ~)
          ::
          ++  pit
            |=  [a=@ b=@]
            =+  c=(rsh 0 1 a)
            =+  [d=(ramp c [3 5 ~] b) e=(ramp c [3 5 ~] +(b))]
            ^+  ^?(..nu)
            ..nu(mos (mul d e), pon [~ (ersa d e)])
          ::
          ++  nol
            |=  a=@ 
            ^+  ^?(..nu)
            =+  b=((hard ,[p=@ q=@]) (cue a))
            ..nu(mos (mul p.b q.b), pon [~ (ersa p.b q.b)])
      --
    ++  pu  ^?
      |%  ++  seal
            |=  [a=@ b=@]
            ^-  [p=@ q=@]
            =+  det=(lte (add 256 (met 0 b)) mx)
            =+  lip=?:(det b 0)
            =+  hec=(cat 7 (shaf %acam lip) (shaf %asel a))
            =+  key=(shas %ales hec)
            :-  key
            =-  (add ?:(p.mav 0 1) (lsh 0 1 q.mav))
            ^=  mav  ^-  [p=? q=@]
            :-  det
            =+  dog=(pad mx [256 hec] lip)
            =+  hog=(push dog)
            =+  ben=(en key b)
            ?:(det hog (jam hog ben))
          ::
          ++  sure
            |=  a=@
            ^-  (unit ,@)
            =+  [det==(0 (end 0 1 a)) bod=(rsh 0 1 a)]
            =+  gox=?:(det [p=bod q=0] ((hard ,[p=@ q=@]) (cue bod)))
            =+  dog=(pull p.gox)
            =+  pig=(dap mx 128 dog)
            =+  log=?:(det q.pig q.gox)
            ?.(=(p.pig (shaf %agis log)) ~ [~ log])
      --
    ++  se  ^?
      |%  ++  sign
            |=  a=@  ^-  @
            =-  (add ?:(p.mav 0 1) (lsh 0 1 q.mav))
            ^=  mav  ^-  [p=? q=@]
            =+  det=(lte (add 128 (met 0 a)) mx)
            :-  det
            =+  hec=(shaf %agis a)
            =+  dog=(pad mx [128 hec] ?:(det a 0))
            =+  hog=(pump dog)
            ?:(det hog (jam hog a))
          ::
          ++  tear
            |=  a=@
            ^-  (unit ,[p=@ q=@])
            =+  [det==(0 (end 0 1 a)) bod=(rsh 0 1 a)]
            =+  gox=?:(det [p=bod q=0] ((hard ,[p=@ q=@]) (cue bod)))
            =+  dog=(punt p.gox)
            =+  pig=(dap mx 256 dog)
            =+  mac=(end 7 1 p.pig)
            ?.  =(mac (shaf %acam q.pig))
              ~
            =+  key=(shas %ales p.pig)
            ?:  det 
              [~ key q.pig]
            =+  cow=(de key q.gox)
            ?~(cow ~ [~ key u.cow])
      --
    --
  ++  brew                                              ::  create keypair
    |=  [a=@ b=@]                                       ::  width seed
    ^-  ac
    (pit:nu:crya a b)
  ::
  ++  hail                                              ::  activate public key
    |=  a=pass
    ^-  ac
    =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
    ?>  =('a' mag)
    (com:nu:crya bod)
  ::
  ++  wear                                              ::  activate secret key
    |=  a=ring
    ^-  ac
    =+  [mag=(end 3 1 a) bod=(rsh 3 1 a)]
    ?>  =('A' mag)
    (nol:nu:crya bod)
  ::::
  ::
  ++  test-rsa
    |=  msg=@tas
    ^-  @
    =+  rsa=(brew 1.024 (shax msg))
    =+  [sal=(shax (shax msg)) key=(shax (shax (shax msg)))]
    =+  sax=(seal:pu:rsa sal msg)
    =+  tin=(tear:se:rsa q.sax)
    ?.  &(?=(^ tin) =(p.sax p.u.tin) =(msg q.u.tin))
      ~|(%test-fail-seal !!)
    =+  tef=(sign:se:rsa msg)
    =+  lov=(sure:pu:rsa tef)
    ?.  &(?=(^ lov) =(msg u.lov))
      ~|(%test-fail-sign !!)
    msg
  --  
=>  |%
    ++  ball  ,@uw                                      ::  statement payload
    ++  base  ,@p                                       ::  host identity
    ++  bird  ,[p=@da q=rock]                           ::  packet in flight
    ++  bond  (list post)                               ::  atomic statement
    ++  code  ,@uvI                                     ::  symmetric key
    ++  cask                                            ::  symmetric record
              $:  yed=(unit ,[p=hand q=code])           ::  outbound
                  heg=(map hand code)                   ::  proposed 
                  qim=(map hand code)                   ::  inbound
              ==                                        ::
    ++  deed  ,[p=base q=mark r=@uw s=pass]             ::  ownership stage
    ++  door                                            ::  foreign contact
              $:                                        :: 
                  wod=road                              ::  connection to
                  fer=road                              ::  inferred conn from
                  caq=cask                              ::  symmetric key state
              ==                                        ::
    ++  drat  ?(0 1 2)                                  ::  NAT none/good/bad
    ++  flap  ,@uvI                                     ::  fragment name
    ++  gram  ,@uw                                      ::  physical datagram
    ++  hair                                            ::  logical datagram
              $%  [& p=@]                               ::  log13 atom
                  [| p=@ud q=(list hair)]               ::  width/13 frags  
              ==                                        ::
    ++  hand  ,@uvH                                     ::  hash of code
    ++  hole  $%([& p=flap] [| p=sock q=well])          ::  flap target
    ::  jack
    ++  lint  (list rock)                               ::  fragment array
    ++  lane                                            ::  packet route
              $%  [%if p=drat q=@ud r=@if]              ::  IPv4 NAT/UDP/addr
                  [%is p=drat q=@ud r=@is]              ::  IPv6 NAT/UDP/addr
              ==                                        ::
    ++  link  ,[p=code q=sock]                          ::  connection
    ++  mace  (list ,[p=mark q=ring])                   ::  secret history
    ++  mark  ,@ud                                      ::  regime number
    ++  post  ,[p=path q=*]                             ::  statement
    ++  rank  ?(%czar %king %duke %earl %pawn)          ::  base width class
    ++  road                                            ::  secured oneway route
              $:  exp=@da                               ::  expiration date
                  lue=(unit lane)                       ::  route to friend
                  lew=will                              ::  will of friend
              ==                                        ::
    ++  rock  ,@uvO                                     ::  packet
    ++  safe                                            ::  domestic host
              $:  loc=(unit lane)                       ::  packet route
                  val=wand                              ::  private keys
                  law=will                              ::  server will
                  seh=(map hand ,[p=base q=@da])        ::  key cache
                  hoc=(map base door)                   ::  friends & relations
              ==                                        ::
    ++  salt  ,@uv                                      ::  entropy
    ++  tray                                            ::  fragment pile
              $:  zep=@da                               ::  last receipt
                  key=code                              ::  encryption
                  loz=hole                              ::  meaning
                  yoo=(list flap)                       ::  assembly
                  hym=[p=@ q=(map flap (unit rock))]    ::  awaiting
              ==                                        ::
    ++  sock  ,[p=base q=base]                          ::  from to
    ++  taxi  ,[p=lane q=rock]                          ::  routed packet
    ++  town                                            ::  all security state
              $:  lit=@ud                               ::  active modulus
                  urb=(map base safe)                   ::  all keys and routes
              ==
    ++  wand  (list ,[p=mark q=ac])                     ::  mace in action
    ++  weft  (list flap)                               ::  fragment probe
    ++  will  (list deed)                               ::  certificate
    --
=>  |%
    ::::
    ++  go
      |_  ton=town
      ::::
      ++  as                                            ::  per server
        |_  [our=base saf=safe]
        ::::
        ++  lax
          |_  [her=base nob=door]
          ::::
          ++  cley                                      ::  client crypto
            ^-  [p=mark q=ac]
            ?~  lew.wod.nob  !!
            [q.i.lew.wod.nob (hail s.i.lew.wod.nob)]
          ::
          ++  kuch                                      ::  hear key tag
            |=  had=hand
            ^-  (unit ,[p=code q=_..kuch])
            =+  wey=(~(get by heg.caq.nob) had)
            ?^  wey
              =+  key=(shas %anex u.wey)
              :+  ~  key
              %=    ..kuch
                  yed.caq.nob  [~ had u.wey]
                  heg.caq.nob  (~(del by heg.caq.nob) had)
                  qim.caq.nob  (~(put by qim.caq.nob) had key)
              ==
            =+  duv=(~(get by qim.caq.nob) had)
            ?~  duv  ~
            [~ u.duv ..kuch]
          ::
          ++  trox                                      ::  expire by date
            |=  [now=@da]
            ^+  ..trox
            !!
          ::
          ++  porq                                      ::  propose connection
            |=  key=code
            ^+  ..porq
            !!
          ::
          ++  wasc                                      ::  hear connection
            |=  [key=code rod=road]
            ^+  ..wasc
            !!
          --
        ++  gub                                         ::  base/key by code
          |=  had=hand
          ^-  [p=(unit ,[p=base q=code]) q=_..gub]
          !!
        ++  myx                                         ::  door by base
          |=  her=base
          ^+  lax
          =+  fod=(~(get by hoc.saf) her)
          ~(. lax [her ?~(fod *door u.fod)])
        ::
        ++  nux                                         ::  install door
          |=  new=_lax
          ^+  ..nux
          ..nux(hoc.saf (~(put by hoc.saf) her.new nob.new))
        ::
        ++  ren                                         ::  renew crypto
          |=  [biz=@ud sed=@]
          ^+  ..nux
          !!
        ::
        ++  sen                                         ::  current crypto
          ^-  [p=mark q=ac]
          ?~(val.saf !! i.val.saf)
        ::
        ++  sev                                         ::  crypto by mark
          |=  kam=mark
          ^-  ac
          ?~  val.saf  !!
          ?:(=(kam p.i.val.saf) q.i.val.saf $(val.saf t.val.saf))
        ::
        ++  tim                                         ::  expire by date
          |=  [now=@da]
          ^+  ..tim
          !!
        ::
        ++  way
          |=  her=base
          |=  her=base
          =+  tae=(lord her)
          ?.  (~(has in urb.ton.fox) tae)
            ?<(=(tae her) $(her tae))
          (need lue:wod:nob:(myx:(need (~(us go ton.fox) tae)) her))
        
        --
      ++  ha                                            ::  adopt new license
        |=  [our=base mec=mace wil=will] 
        ^-  town
        !!
      ++  pw                                            ::  pwned by?
        |=  [our=base wil=will]
        ^-  [p=? q=town]
        !!
      ++  su                                            ::  install safe
        |=  new=_as
        ^-  town
        ton(urb (~(put by urb.ton) our.new saf.new))
      ::
      ++  sy                                            ::  forge wild base
        |=  [biz=@ud sed=@]
        ^-  [p=base q=_..su]  
        !!
      ::
      ++  ti                                            ::  expire by time
        |=  [now=@da]
        ^-  town
        !!
      ::
      ++  us                                            ::  produce safe
        |=  our=base
        ^-  (unit ,_as)
        =+  goh=(~(get by urb.ton) our)
        ?~  goh  ~
        [~ ~(. as [our u.goh])]
      ::
      ++  wa                                            ::  route packet
        |=  [yer=base pac=rock]
        ^-  (list taxi)
        !!
      --
    ::::
    ::
    ++  clan                                            ::  base to rank
      |=  who=base  ^-  rank
      =+  wid=(met 3 who)
      ?:  (lte wid 1)   %czar
      ?:  =(2 wid)      %king
      ?:  (lte wid 4)   %duke
      ?:  (lte wid 8)   %earl
      ?>  (lte wid 16)  %pawn
    ::
    ++  lord                                            ::  default seigneur
      |=  who=base  ^-  base
      =+  mir=(clan who)
      ?-  mir
        %czar  who
        %king  (end 3 1 who)
        %duke  (end 4 1 who)
        %earl  (end 5 1 who)
        %pawn  (end 4 1 who)
      ==
    ::
    ++  zeno                                            ::  imperial keyprint
      |=  zar=@pD
      ^-  @uvH
      %^    cut 
          7 
        [zar 1]
      0v2i1f.o8f3m.b3pb3.m2mhe.gh1p7.uli50.9ac6e.cf6iq.nkot2.9hb9b.taobq.
       u0plo.njocn.c9g52.cab47.d2h9m.fivm2.q5cts.it1on.2akfm.7io1a.8u8nu.
       p40f4.uqc5f.hpvsv.34kth.sr3j9.rkto4.8fddi.k9mmg.n184j.rd6gl.qib0f.
       imuvo.g5862.39si7.kgmt3.7u8bn.ka7vg.oho5m.kal0d.f4lm0.qonos.2832k.
       3t0oj.nrdqo.d62di.demo2.1c6bc.bbpsu.s87dg.n0idr.5rrf3.ecd75.v8q0f.
       sfu55.f3ac7.kpfd5.lp7e2.roqfi.5ro0i.cuk1h.q52gh.d3lk8.94lc0.t2e8v.
       iscp2.koqec.r5naa.49f6v.o5c6b.sj1hp.13kv6.rl47r.8i9kh.rsi3h.cfmfg.
       ocb7i.k0ogk.v2ug9.a4ah8.5u8qo.dfjna.2knqv.2errk.cmqjv.s4eug.j95p8.
       74ah9.me4ko.ffvpd.g69e2.gbqs3.paps9.8m3na.1ij3m.f7kg9.cnukp.nmpku.
       p0dhf.ru29a.hr7ed.d6avb.eprug.80jb6.qgv65.bp4vg.ffbkj.parns.kbl53.
       5m3iv.iv39o.4ahi8.agkq7.pq05l.e66na.41t01.q5fij.ja48q.lha1f.56den.
       84fh6.f3fh5.q70c6.qgf72.mi7gq.d13s5.421bj.u40iv.vm9g5.kruki.0bj0k.
       9c2hi.o17pf.k8i7k.vqcv9.c5kc5.s76ap.4gg34.gi2c1.rm1jn.qfp82.41n9n.
       qno05.rul69.nigbd.fi1qj.05cmu.saev5.s1hdm.dds0m.9rjq2.cgfna.pta0k.
       lbtcv.p2ebi.um9l6.0pmgq.ae480.4mt89.77m13.fbq22.qkj55.m2l5q.k7e3b.
       hc2m5.guduc.4f7l9.79v2q.5hk8a.dfuh8.huno7.laspt.dce6u.m50ng.aqn5b.
       f1vdm.k910j.onu0a.a78f5.o9r4b.cs80b.02p95.2pohv.oletg.gm31g.vs0rt.
       k3mgm.2c9kq.jrs1l.3fof9.l0aa3.seaij.oeafs.p9n1f.31ve7.ab5u6.ti8c1.
       vhuf2.80q45.5hl5g.9n6m5.5afr7.q5vl0.aic2a.b2a4o.dda6g.tfu8l.nmko1.
       4ifrt.jcnd9.7te49.o5via.r4ttu.uit8t.k48iv.5gqf8.0p906.rijpq.q1r1d.
       1k3b9.v7p9j.eo6dk.s3nmf.bfkr5.h940l.ccdh6.v82d6.ouaj0.aivhs.kmg13.
       qepbl.ns28h.8bapb.p8h8j.87j3s.lfu9d.8um44.0tlkn.lrb70.nqlrj.pd7l0.
       feom7.88u7u.r9kdb.8lg8u.ra9n4.qk176.u829f.cpq89.650o9.2uk0v.5vq6p.
       lun69.js0hl.7a0nm.7kuku.u25ee.0popf.78904.1vasg.l5ced.drdnn.0u84d.
       cotq5.u37od.lqned.33blp.eipsn.hv268.qtavc.mt40e.oohqc.0fiie.6caqa.
       p7lv3.0jonh.n1clt.hc386.emog7.30jeq.evq6o.l0k21.mp9c1.g31bu.np5k5.
       p7v5k.d31vg.9ecm8.avh0o.spfv4.0igpo.hp63a.fcs58.mmnr3.tana1.8b2mu.
       1l8ab.560oq.km9om.jiftk.15st8.t8m0a.ipam8.qnac7.kv01u.c3gjk.i3771.
       p1mml.u33tf.rkls0.mqodj.c4h37.kvn1p.3gsun.quouu.5217b.3neg8.pvchk.
       2gjtg.psmm1.ret6g.v1f58.1v9mu.uteh4.a8vse.4ciu7.88mf7.4q5in.nd9f3.
       99a2m.ch49i.3tg57.auvh5.fpa9i.ghhd6.a1lbd.k4qji.ur956.otbs9.u02ku.
       3c6lo.jcka1.b7ba1.2lo9v.1euef.eudnt.unv1i.30qi4.bhk65.vgk3f.vpao9.
       t9lrf.tb63o.p1p7v.pq8jv.mh1uv.p9c2i.rqeq9.hkm6d.n917q.gumuo.3nbge.
       080a5.ctigb.cko5m.brpf1.l6kf8.2qgmu.aosv6.anfmg.gtpka.hjevh.50lcr.
       lqs51.ou3jr.0aon9.o4gpd.q193g.vra8o.oddfc.hcpui.n06a5.9h432.i4ar7.
       k3af6.uqopi.v9dur.a7e20.qfbgd.buq82.7191b.6728c.ni47f.2ffd8.0a07h.
       j6v0u.t24c3.19444.n9kci.e287q.fisv9.amijk.6nabd.luqhh.ninu4.gg046.
       kr0e2.ck64u.h6rls.99qbr.objcf.v14du.tmu5k.io5sl.uk6qj.hd61t.fpupg.
       64v21.6bn6c.p6gvs.1tr6u.gnqhn.45qjt.94vsc.2alul.lrl6t.n96g1.clb13.
       q2b8k.ondm2.9d5au.n59qa.hokov.mucdu.nocr8.j59mo.u2rf1.6k08t.1pj7a.
       6v865.3qil2.13q7r.iek59.vugae.bnh69.rktb5.ek340.5tj9f.7tgi0.l52g0.
       jp03q.g01b0.m1vt3.765h2.e3nt8.euo76.1e2i1.f0ot1.d3uj3.5n0ll.lj7tr.
       p9tq8.qa0hs.m689e.3nmpk.jb86b.4ak2p.0pkc2.49emo.gvigp.1kveh.l7787.
       uit37.bhvu6.rk5i7.r6l85.uejuj.9pfls.64kco.qd86i.604vq.18ked.skq91.
       f9sn3.dn3hc.3km7h.r7uhr.cnbm3.2os38.hqe4l.qigmq.hd3fm.l9n9f.okf6b.
       dfosh.g3uoi.9nqc8.i9o3j.odhfg.8iqj9.ukmo1.k2qvk.4rhsg.g7j4h.g0nrt.
       c4dln.pah8p.h7dg7.u6ejk.ldlm5.sa110.ka9pg.36ffc.9plm4.0qs6k.sgiq3.
       sg3a3.5d0id.mfhrj.fiiud.uu0qc.c8nnv.odcil.5dk2g.snmmd.9f1fg.1njm5.
       1rbdk.70cl1.nqdrp.os17b.m1b3v.q0mud.r8oon.fo9h4.jkju7.u7q58.sevpp.
       t0f60.tjpmc.p573i.lknoc.umthj.skvop.ndr30.97doa.b8phq.pe3hb.ucijv.
       h3nbd.j9ptf.9p0u3.thk3r.2ljua.moqns.ss9p4.fe3nf.98iv5.4a0qb.jus4u.
       tbbgm.9k4gi.323hr.fvpkc.9s5a3.t0qrh.jv50i.mjs7o.48mj7.msfoi.bv0hr.
       26nk7.m551u.48ujv.225nt.u8mgk.bh8mv.45dfv.ouau4.d6qp7.01hj8.rn3sb.
       q61vl.v47ub.4hmfg.pbt3f.00nvm.a74eh.0r3vh.9ctm7.4vmqe.vlc05.7oof6.
       tphlo.8h6s4.v5oj5.sgj05.ftf7g.98508.tkoqe.c1ps0.iteq3.vbk5k.51rka.
       vrps6.u3mou.qe73r.0qc4l.v9t1l.1th3u.f3c88.548mv.7mnu5.2j463.grk1m.
       033jl.5goj8.9ru1e.cjrhp.mnbnc.mfsr3.j28lq.21lo9.nad85.5ed87.j8mss.
       dkkd3.chv14.ssav4.78i5a.rh787.59jsa.l3fuq.m5opn.hnpdd.3taod.sak8b.
       i3918.qeg9m.jp0e2.6cci1.28rap.35oas.ik8f3.j9vl6.j86mc.omlbu.rcg8o.
       n9qv6.0jjl8.e8sua.9n9n1.26k9e.uso90.alpd4.gvbj0.q4h5s.depk8.csu2e.
       3h8r9.tmpis.4qigv.n80pu.2iptl.b5a89.ocdd2.9kj8o.df5sc.o19pu.butnl.
       tj8c5.0llkt.m5a9j.g8h3q.0h4go.kaa3c.mj32k.va73a.jpn6r.8e0lr.e8ve5.
       8ku8a.s8m7v.7f2js.sc4g4.8m2ra.6mpju.9l4h4.l8sjm.pg0dk.fvcjg.8veeg.
       2b906.mp4uo.rfmn6.qu842.vmn94.qssgc.o97gu.o9p15.0bv79.q76n7.63950.
       93acd.0tetr.tim58.4u7pb.a569k.aglmm.udftf.s80b5.poftj.5d072.6itts.
       fhatt.f8699.n3don.09vd1.kb2ds.qjlu5.ca392.76u12.sjv25.rms26.mhfro.
       l8soh.jkfs7.iqj43.01mdn.tajbb.p8f4v.7fuc6.8bjrk.09uou.3ioq4.l8mnh.
       d3u38.u4qro.35h0g.pcmfi.54s0m.i5846.jia8d.ui1q6.jgs3c.egjbk.7hjg6.
       lfbrj.l9ain.83e3b.a94da.afv54.kmsj6.0bb2k.2gb2g.svcpn.gst8t.lsfpb.
       kncrp.7t8f8.nun72.rlqep.at7cp.4v1i6.06tm5.q0b0u.ik7u0.tkael.altoe.
       5nmcd.bi5lp.h4dsf.anhdi.aouid.al2rp.h1vu9.snk5q.maktq.1khhg.49ieb.
       tj6dr.rlr03.i2p2c.80srs.uc2pt.mumr5.ssesp.ajua4.t3ug9.qsuea.lsv2r.
       tli3v.mkc2j.3lfla.ridcq.g8sa0.0h3cn.un304.4actv.s1soh.d8if2.h7i1s.
       962hr.capvc.nn9ql.ji7ab.jqnf9.kcbqh.f7cdc.a6dib.e0n2v.0h2cr.lbgcq.
       o8621.ici78.f63vr.innc7.oak4l.bifdi.er1gr.5rng9.ku8ec.b8057.ot0v1.
       0bcut.nbeu6.30tnu.8t6nm.eoi0f.aa8v0.so16p.v3s3g.17c17.8b33u.9204h.
       47e82.7fdvs.97al0.rvf3p.g5898.1r4g0.5sa8h.lto8i.k6jmp.1ba8t.233rl.
       qdm9i.q2oun.uu25l.3h4jh.g5pg6.pju8o.uapdr.ibc1u.vm1he.eloov.1tj0j.
       8lacq.88li3.sv3ol.9162v.n4g0p.r854m.nfoqs.8bl8a.702io.k50on.j6g73.
       ib5o2.kdp9p.rlk17.ht6e6.n8177.t46ih.fs12o.349s4.2jk85.6ap6h.ql0sv.
       ske4g.4bbff.dlebf.5itih.1rvjh.opm64.73skm.8aa1b.psqvl.e8pjq.4et0p.
       i3vpn.clkne.r26qm.lqadj.o54o9.jkdr9.g8nia.8th9t.0nfih.gln8h.4v1c6.
       s6fih.j62dk.efj4o.ncgs5.2mets.s7q68.g5mms.fo5m1.lp6vj.khvku.ht6p7.
       l7435.ucgin.h36te.b8qj4.etc8e.decre.tqtme.1cnfu.oig80.5hubk.ba946.
       vgdka.50111.uqa5e.7dmad.g5ihl.bfru5.cmsut.58ei6.hdicf.qu9l3.ug950.
       154sv.jdat8.es3ks.9f9mc.pnvoi.urmgt.l2te5.4ref7.jfkih.bbdg7.9j4d2.
       2luv2.o4q5r.k8a5t.i4rf0.6rq58.vlpuf.bnhvc.9ueqd.3nb9q.ri7jb.fq6ko.
       s10ij.ndnda.9tpie.1aoh2.umjhl.4ferf.ofut7.8nvlr.ek3cv.0ir8f.mhvd1.
       21sv9.6su3u.kruos.mh7ig.jpa61.a9ntj.i2lak.j9pri.v1oro.d6q2j.gu339.
       rret9.hpmrl.rqbn8.25un7.oi92h.2p78v.obd3h.nlkdo.c1kpi.lp23k.l8i1f.
       qtl7j.8f582.i66ei.c3dgo.plgbq.afmcb.ov7no.1s15c.956lo.15vip.hk1ol.
       l853h.p481g.n471n.r2g12.nuk9a.ivfto.09dtk.2a2en.gmi10.el9cv.3i05v.
       hbir3.ut8eo.fr0ar.cjjio.rto4k.dk0f2.7dnv5.q96oc.qm4kn.5bgkh.i1jbt.
       gjn6g.kei00.ac2h5.266bq.0l1mc.0odep.3mcji.ru97r.r5to8.hmp6l.bdlri.
       rje6e.5o74l.960n1.up0hi.5rvv3.j8e56.eajnj.mfpeq.vr820.5jot8.a3a0h.
       m3vdv.hpqas.j8t9h.h6opl.0du61.c47n1.v8cm6.t2h7p.bggol.p6iun.t54ol.
       snp38.n93sk.4gvf4.do2ru.vh94a.fmj4s.adm0g.4p6dr.tjphq.3tsv5.fas80.
       po9ri.pbc4a.l72il.gm4ba.stnai.lor6r.7ocv7.910pa.96o24.9qi9j.gjbhb.
       iqipj.h68t7.6s2dl.91lsc.n01k6.ce8dv.9v936.hne43.ueapt.usb14.5v49e.
       br3vs.malnf.hkopo.11qd1.iapks.b3dfc.b40ac.fu4pf.jjl1f.pliqq.515ea.
       6otn8.a20j8.pe8bq.0q186.loq12.em0h9.p6v4t.nvdej.cjabj.g6j5c.07d8j.
       g751i.ab5n8.3hbdl.gvpko.9bcjf.1ilf1.eppj9.85q6q.c8ggf.7ddg3.cmh7k.
       kgmvs.1fg21.l1ig3.fhcls.q240c.2975k.h2gme.bql1u.lm52n.40mdf.8ud10.
       8dmrk.ljujh.qh0k9.8k1pf.obomh.2ddpf.9mh9g.m1m33.h9plm.79jtp.q4jlq.
       nhi0t.ruu1a.8qvtt.e55jj.05cn0.ompje.voqqc.bndna.47o49.v2oih.5sqen.
       tohlk.e0kpg.ki3jl.ckomt.kbffp.f2mm2.sjrmb.ilejc.0k2da.tju5l.4r681.
       702hc.dhq7s.rb9od.ngqvl.1npp5.d19iu.3ber1.s49q7.9r1gj.kfif8.ofmtg.
       3iktq.tc5th.022as.vsfvm.tst48.hpnjp.k8c6d.t4u6a.ealql.j5gu4.v7gd5.
       qrolf.sro7e.ac5p9.flprh.00ep2.09fdi.ed6hf.tg3vp.jj8bd.mg9gk.o83b3.
       1u6u7.hls27.ji1fj.rptfq.scjdm.14l0j.jgvqg.g8q0m.jccan.6a0iv.qickd.
       0to72.sbujm.oi150.6dgjg.fagn8.eeqgm.0g4tm.i6083.trr14.6ibuq.pe3ss.
       mvpo1.lrg1i.341ea.vmn1d.hd22b.6b0au.5nr99.ed7nu.lnknl.gt6ia.a4rcd.
       2f7q1.nhui7.kn8la.2k2lf.5mg4b.7gq5p.9ptna.02fhk.0lr57.em495.v29gh.
       idq5o.pcvch.aq45i.3mdil.spqp5.surh7.oqk0n.mv1n0.ib4tm.4g6gc.9jlkj.
       7bvij.ci0ma.4roqq.je13a.s71li.jiscq.fbdgv.m73nq.284gq.q6vkl.noqtr.
       n0oub.vafgc.anjf2.cpvaa.244fq.j95hu.r818c.2dgsu.25oih.ngeiv.60iff.
       svd9l.n6j8a.edofe.mguro.ulmhh.q8iuv.bjrim.c9f4l.g2i3n.qmcsn.q0hni.
       gkpsq.dl1im.l2mek.8p6qj.8nki4.7m5kl.bm92c.cqst8.h8b5r.2high.md8g9.
       d25fm.crl53.8mnlu.68ib6.d9f0p.hmriv.hmp3a.tbhcl.8mmfu.sthuc.9fs26.
       nj6eg.bmlm6
    --
=>  |%                                                  ::  fort top level
    ++  band  ,@uvH                                     ::  network packet id
    ++  bait  ,[p=rind q=dove]                          ::  fragment target
    ++  bone                                            ::  fort output
              $%  [%beer p=base]                        ::  gained ownership
                  [%coke p=cape q=soap]                 ::  message conclusion
                  [%milk p=sock q=@da r=bond]           ::  network discovery
                  [%sake p=sock q=meal]                 ::  one-way message
                  [%wine p=base]                        ::  lost ownership
              ==                                        ::
    ++  cape                                            ::  end-to-end result
              $?  %dead                                 ::  prob undelivered
                  %good                                 ::  delivered
                  %weak                                 ::  rejected
              ==                                        ::
    ++  cake  ,[p=gage q=base r=rind s=@]               ::  top level packet
    ++  dove  ,[p=@ud q=@ud r=(map ,@ud (unit ,@))]     ::  width-13 count data
    ++  flow                                            ::  packet connection
              $:  liz=@da                               ::  last receipt
                  rtt=@dr                               ::  round trip time
                  rat=@ud                               ::  rtt bytes/sec
              ==                                        ::
    ++  fort                                            ::  formal state
              $:  ton=town                              ::  security
                  vig=(map base sink)                   ::  incoming per serv
                  von=(map base oven)                   ::  outgoing per serv
              ==                                        ::
    ++  gage  ,@udC                                     ::  fragment gage
    ++  limb  ?(%back %bond %buck %carp %lump %neck)    ::  content stem
    ++  meal                                            ::  payload
              $%  [%back p=base q=cape r=band]          ::  acknowledgment
                  [%bond p=base q=(list post)]          ::  statement
                  [%buck p=base q=will r=mace]          ::  license
                  [%carp p=flap q=@]                    ::  leaf fragment
                  [%lump p=@]                           ::  wrapped packet
                  [%neck p=base q=lane]                 ::  self-route
              ==                                        ::
    ++  note  ,[p=soap q=sock r=meal]                   ::  output source
    ++  oven                                            ::  outgoing per serv
              $:  dow=(map base flow)                   ::  default flows
                  par=(map soap putt)                   ::  messages in process
              ==                                        ::
    ++  putt                                            ::  outgoing message
              $:  fow=flow                              ::  connection metrics
                  wyv=(gear rock)                       ::  packet generator
              ==                                        ::
    ++  rind  ,[p=skin q=limb]                          ::  format 
    ++  skin  ?(%none %open %fast %full)                ::  encoding stem
    ++  slaw  (list bone)                               ::  reflected product
    ++  sink                                            ::  incoming per server
              $:  duc=(map flap band)                   ::  fragment to action
                  nes=(map band (list bait))            ::  fragment actions
              ==                                        ::
    ++  soap  ,*                                        ::  opaque msg identity
    --
=>  |%
    ++  bite                                            ::  packet to cake
      |=  pac=rock  ^-  cake
      =+  [mag=(end 5 1 pac) bod=(rsh 5 1 pac)]
      =+  :*  chk=(end 0 17 mag) 
              dit=(cut 0 [17 3] mag)
              wix=(bex +((cut 0 [20 2] mag)))
              tay=(cut 0 [22 5] mag)
              mal=(cut 0 [27 5] mag)
          ==
      ?>  =(chk (end 0 17 (mug bod)))
      :^    dit
          `@p`(end 3 wix bod)
        :-  (snag tay [%none %open %fast %full ~])
        (snag mal [%back %bond %buck %carp %lump ~])
      (rsh 3 wix bod)
    ::
    ++  chew                                          ::  process datagram
        |=  [now=@da bad=band]
        |=  [bax=base rym=rind msg=gram]
        ^-  [p=(list bone) q=fort]
        =+  [who=*(unit base) yek=*(unit code)]
        =+  gus=(need (~(us go ton.fox) bax))
        =+  vif=`sink`=+(vif=(~(get by vig.fox) bax) ?~(vif *sink u.vif))
        =+  wof=`oven`=+(wof=(~(get by von.fox) bax) ?~(wof *oven u.wof))
        =+  [lub=*(list bone) yow=*(list taxi)]
        =<  mane
        |%
        ++  bran
          |-  ^-  .
          ?-    p.rym
              %none
            ?-    q.rym
                %back
              !!
            ::
                %bond
              !!
            ::
                %buck
              !!
            ::
                %carp
              !!
            ::
                %lump
              ((gnaw now) msg fox) 
            ::
                %neck
              !!
            ==
          ::
              %fast
            =+  [mag=`hand`(end 7 1 msg) bod=(rsh 7 1 msg)]
            =+  yoq=(gub:gus mag) 
            =>  ^+(. .(gus q.yoq))
            ?>  ?=(^ p.yoq)
            %=  $
              p.rym  %none
              who    [~ p.u.p.yoq]
              msg    (dy:q:sen:gus q.u.p.yoq msg)
            ==
          ::
              %full                                 ::  signed and sealed
            =+  mex=((hard ,[p=mark q=@]) (cue msg))
            !!
          ::
              %open
            =+  ^=  mex
                %.  (cue msg)
                (hard ,[p=[p=base q=mark] q=(unit lane) r=will s=bond])
            !!
          ==
        ++  mane
          ^-  [p=slaw q=fort]
          :-  [(flop lub) (flop yow)]
          %=  fox
            ton  (~(su go ton.fox) gus)
            vig  (~(put by vig.fox) bax vif)
            von  (~(put by von.fox) bax wof)
          ==
        --
      ::
      ++  gnaw                                          ::  process packet
        |=  now=@da 
        |=  pac=rock
        ^-  [p=(list bone) q=fort]
        !!
      ::
      ++  hark                                          ::  next act before
        |=  now=@da
        ^-  @da
        !!
      ::
      ++  reap                                          ::  extract until
        |=  now=@da
        ^-  [p=(list bone) q=fort]
        !!
      ::
      ++  wait                                          ::  await fragments
        |=  [now=@da ack=band]
        |=  [bax=@p rym=rind [kas=@ cub=@] fox=fort]
        ^-  fort
        !!
      ::
      ++  wash                                          ::  send messages
        |=  now=@da
        |=  noy=(list note)
        ^-  [p=(list bone) q=fort]
        !!
      ::
      ++  wish                                          ::  send message
        |=  now=@da
        |=  [sup=soap soq=sock ham=meal]
        ^-  [p=(list bone) q=fort]
        !!
      -- 
=>  |%                                                  ::  protocol engine
    ++  am
      |_  fox=fort
      ++  chew
        |=  [now=@da ack=band]
        |=  [bax=base rym=rind msg=@]
        ^-  [p=slaw q=fort]
        =+  [who=*(unit base) yek=*(unit code)]
        =+  gus=(need (~(us go ton.fox) bax))
        =+  vif=`sink`=+(vif=(~(get by vig.fox) bax) ?~(vif *sink u.vif))
        =+  wof=`oven`=+(wof=(~(get by von.fox) bax) ?~(wof *oven u.wof))
        =+  [lub=*(list bone) yow=*(list taxi)]
        =<  mane
        |%
        ++  bran
          |-  ^-  .
          ?-    p.rym
              %none
            ?-    q.rym
                %back
              !!
            ::
                %bond
              !!
            ::
                %buck
              !!
            ::
                %carp
              !!
            ::
                %lump
              ((gnaw now) msg fox) 
            ::
                %neck
              !!
            ==
          ::
              %fast
            =+  [mag=`hand`(end 7 1 msg) bod=(rsh 7 1 msg)]
            =+  yoq=(gub:gus mag) 
            =>  ^+(. .(gus q.yoq))
            ?>  ?=(^ p.yoq)
            %=  $
              p.rym  %none
              who    [~ p.u.p.yoq]
              msg    (dy:q:sen:gus q.u.p.yoq msg)
            ==
          ::
              %full                                 ::  signed and sealed
            =+  mex=((hard ,[p=mark q=@]) (cue msg))
            !!
          ::
              %open
            =+  ^=  mex
                %.  (cue msg)
                (hard ,[p=[p=base q=mark] q=(unit lane) r=will s=bond])
            !!
          ==
        ++  mane
          ^-  [p=slaw q=fort]
          :-  [(flop lub) (flop yow)]
          %=  fox
            ton  (~(su go ton.fox) gus)
            vig  (~(put by vig.fox) bax vif)
            von  (~(put by von.fox) bax wof)
          ==
        --
      -- 
    ::
    ++  gnaw
      |=  now=@da 
      |=  [pac=rock fox=fort]
      ^-  [p=slaw q=fort]
      =+  kec=(bite pac)
      =+  wel=(shaf %well pac)
      ?.  (~(has in urb.ton.fox) q.kec)
        =-  [[~ [[fwd pac] ~]] fox]
        ^=  fwd
        |-  ^-  lane
        =+  tae=(lord q.kec)
        ?.  (~(has in urb.ton.fox) tae)
          ?<(=(tae q.kec) $(q.kec tae))
        (need lue:wod:nob:(myx:(need (~(us go ton.fox) tae)) q.kec))
      ?:  !=(0 p.kec)
        [[~ ~] ((wait now wel) q.kec r.kec [p.kec s.kec] fox)]
      ((chew now wel) q.kec r.kec s.kec fox)
    ::
    ++  spit
      |=  kec=cake  ^-  @
      !!
    ::
    ++  wack                                                ::  compose ack
      |=  [soq=sock ack=well]
      ^-  taxi
      !!
    ++  wade
      |=  pac=rock  ^-  well
      (shaf %well pac) 
    --
|%
::
++  zuul
  !!
--
