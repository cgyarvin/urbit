:: Cato pre-300K.
::

|+

 ::::::::::  Tier 0: simple logic and arithmetic
 ::::::::::

   ::::::::  add                 atomic add
   ::
    - add
      ||  @
        a = @
        b = @
      ==
        ?:  (zil a)
          b
        $(a (dec a), b (inc b))

   ::::::::  dec                 atomic decrement
   ::
    - dec
      ||  @
        a = @
      ==
        ?<  (zil a)
        :>  b 0
        |-
          ?:  (eq a (inc b))
            b
          $(b (inc b))

   ::::::::  div                 atomic divide (a / b)
   ::
    - div
      ||  @
        a = @
        b = @
      ==
        ?<  (zil b)
        :>  c 0
        |-
          ?:  (lte a b)
            c 
          $(a (sub a b), c (inc c))

   ::::::::  eq                  noun equality
   ::
    - eq
      ||  ?
        a = *
        b = *
      ==
        :6.[a b] 

   ::::::::  gt                  atomic greater than (a > b)
   ::
    - gt
      ||  ?
        a = @
        b = @
      ==
        !(lte a b)

   ::::::::  gte                 atomic greater-or-equal (a >= b)
   ::
    - gte
      ||  ?
        a = @
        b = @
      ==
        !(lt a b)

   ::::::::  inc                 atomic increment
   ::
    - inc
      ||  @
        a = @
      ==
        :5.a

   ::::::::  lt                  atomic less-than (a < b)
   ::
    - lt
      ||  ?
        a = @
        b = @
      ==
        ?&
          !(eq a b)
          |-
            ?:  (zil a)
              &
            ?:  (zil b)
              |
            $(a (dec a), b (dec b))
        ==

   ::::::::  lte                 atomic less-or-equal (a <= b)
   ::
    - lte
      ||  ?
        a = @
        b = @
      ==
        ?|
          (eq a b)
          (lt a b)
        ==

   ::::::::  mod                 modulus (a % b)
   ::
    - mod
      ||  @
        a = @
        b = @
      ==
        ?<  (zil b)
        (sub a (mul b (div a b)))

   ::::::::  mul                 atomic multiply
   ::
    - mul
      ||  @
        a = @
        b = @
      ==
        :>  c 0
        |-
          ?:  (zil a)
            c
          $(a (dec a), c (add b c))

   ::::::::  pat                 noun is @
   ::
    - pat
      ||  ?
        a = *
      ==
        !(tap a)

   ::::::::  sub                 atomic subtract (a - b)
   ::
    - sub
      ||  @
        a = @
        b = @
      ==
        ?:  (zil b)
          a
        $(a (dec a), b (dec b))

   ::::::::  tap                 noun is cell
   ::
    - tap
      ||  ?
        a = *
      ==
        :4.a

   ::::::::  zil                 @ is 0
   ::
    - zil
      ||  ?
        a = @
      ==
        (eq 0 a)


::::::::::  Tier 1: lists
::::::::::

  ::::::::  list                linked list
  ::
    - list
      |:  z = ~*
      ==
        |~
        **
          ~
          [i=z t=(list z)]
        ==

  ::::::::  flip                invert list
  ::
    - flip
      |.  z
        z = (list)
      ==
        :>  a   =z.~
        |-
          ?-  z
            -   ~   
              a
            -   ^   
              $(z t.z, a [i=i.z t=a])
          ==

  ::::::::  lent                length of list
  ::
    - lent
      ||  @
        z = (list)
      ==
        ?-  z
          -   ~   0
          -   ^   (inc $(z t.z))
        ==


  ::::::::  skim                select list items
  ::
    - skim
      |.  x
        x = (list)
        y = ~?
      ==
        ?-  x
          +   ~
          -   [i=* t=*]
            ?:  (y i.x)
              [i=i.x t=$(x t.x)]
            $(x t.x)
        ==

  ::::::::  sort                sort a list (quicksort)
  ::
    - sort
      |.  x
        x = (list)
        y = ~?
      ==
        ?-  x
          +   ~
          -   [i=* t=*]
            :+  weld
              $(x (skim t.x |:{b=* (y b i.x)}))
              [i.x $(x (skim t.x |:{b=* !(y b i.x)}))]
            ==
        ==

  ::::::::  turn                transform a list
  ::
    - turn
      |:  x = (list) 
          y = ~*
      ==
        ?-  x
          +   ~
          -   ^
            [i=(y i.x) t=$(x t.x)]
        ==

  ::::::::  weld                concatenate lists
  ::
    - weld
      |:  x = (list)
          y = (list)
      ==
        ?-  x
          -   ~
            y
          -   [i=* t=*]
            [i.x $(x t.x)]
        ==

==
