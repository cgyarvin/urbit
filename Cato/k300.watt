:: Cato pre-300K.
::

|+

::::::::::  Tier 0: simple logic and arithmetic
::::::::::

  ::::::::  add                 atomic add
  ::
    - add
      ||  @
        a = @
        b = @
      ==
        ?:  (zil a)
          b
        $(a (dec a), b (inc b))

  ::::::::  dec                 atomic decrement
  ::
    - dec
      ||  @
        a = @
      ==
        ?<  (zil a)
        =>  b 0
        |-
          ?:  (eq a (inc b))
            b
          $(b (inc b))

  ::::::::  div                 atomic divide (a / b)
  ::
    - div
      ||  @
        a = @
        b = @
      ==
        ?<  (zil b)
        =>  c 0
        |-
          ?:  (lte a b)
            c 
          $(a (sub a b), c (inc c))

  ::::::::  eq                  noun equality
  ::
    - eq
      ||  ?
        a = *
        b = *
      ==
        :6.[a b] 

  ::::::::  gt                  atomic greater than (a > b)
  ::
    - gt
      ||  ?
        a = @
        b = @
      ==
        !(lte a b)

  ::::::::  gte                 atomic greater-or-equal (a >= b)
  ::
    - gte
      ||  ?
        a = @
        b = @
      ==
        !(lt a b)

  ::::::::  inc                 atomic increment
  ::
    - inc
      ||  @
        a = @
      ==
        :5.a

  ::::::::  lt                  atomic less-than (a < b)
  ::
    - lt
      ||  ?
        a = @
        b = @
      ==
        ?&
          !(eq a b)
          |-
            ?:  (zil a)
              &
            ?:  (zil b)
              |
            $(a (dec a), b (dec b))
        ==

  ::::::::  lte                 atomic less-or-equal (a <= b)
  ::
    - lte
      ||  ?
        a = @
        b = @
      ==
        ?|
          (eq a b)
          (lt a b)
        ==

  ::::::::  mod                modulus (a % b)
  ::
    - mod
      ||  @
        a = @
        b = @
      ==
        ?<  (zil b)
        |-
          ?:  (lt a b)
            a
          $(a (sub a b))
    
  ::::::::  mul                 atomic multiply
  ::
    - mul
      ||  @
        a = @
        b = @
      ==
        =>  c 0
        |-
          ?:  (zil a)
            c
          $(a (dec a), c (add b c))

  ::::::::  exp                 atomic exponent (a ** b)
  ::
    - exp
      ||  @
        a = @
        b = @
      ==
        =>  c a
        |-
          ?:  (zil b)
            1
          ?:  (eq b 1)
            a
          $(a (mul a c), b (dec b))

  ::::::::  sqt            atomic squareroot (sqrt(a))
  ::::::::                 uses Newton's method.
  ::
    - sqt
      ||  @
        a = @
      ==
        => g 1
        |-
          => b (mul g g)
          ?:  (gt b a)
            ?:  (zil g)
              0
            $(g (dec g))
          => d (div (sub a b) (mul 2 g))
          ?:  (zil d)
            g
          ?:  (gt d g)
            $(g (add g g))
          $(g (add g d))

  ::::::::  pat                 noun is @
  ::
    - pat
      ||  ?
        a = *
      ==
        !(tap a)

  ::::::::  sub                 atomic subtract (a - b)
  ::
    - sub
      ||  @
        a = @
        b = @
      ==
        ?:  (zil b)
          a
        $(a (dec a), b (dec b))

  ::::::::  tap                 noun is cell
  ::
    - tap
      ||  ?
        a = *
      ==
        :4.a

  ::::::::  zil                 @ is 0
  ::
    - zil
      ||  ?
        a = @
      ==
        (eq 0 a)


::::::::::  Tier 1: recursive data structures
::::::::::

  ::::::::  list                linked list
  ::
    - list
      ->  [a=*]
      |=
        |~
          **
            ~
            [i=a b=(list a)]
          ==

  ::::::::  bush    
  ::
    - bush
      ->  [a=@ b=*]
      |=
        |~
          ** 
            [p=@:a q=b]
            [p=[* *]:(bush a b) q=(bush a b)]
          ==
==
