^<  mine.[~ [%watt 270] ~]
|*
  ::  Tier 1, light math
::::
::
    add
  ^<  mine.[!=(->) %add ~]
  |>  [a=@ b=@] 
  ^-  @
  ?:  .=(0 a)
    b
  $(a (dec a), b .^(b))
::::
::
    bex
  ^<  mine.[!=(->) %bex ~] 
  |>  [a=@]
  ^-  @
  ?:  .=(0 a)
    1
  (mul 2 $(a (dec a)))
::::
::
    dec
  ^<  mine.[!=(->) %dec ~] 
  |>  [a=@]
  ^-  @
  ^>  bean.%dec
  ?<  .=(0 a)
  =+  b=@
  |-
  ?:  .=(a .^(b))
    b
  $(b .^(b))
::::
::
    div
  ^<  mine.[!=(->) %div ~] 
  |>  [a=@ b=@]
  ^-  @
  ^>  bean.%div
  ?<  .=(0 b)
  =+  c=@
  |-
  ?:  (lth a b)
    c
  $(a (sub a b), c .^(c))
::::
::
    fib
  |>  a=@
  ^>  memo
  ^-  @
  ?-    a
      0   0
      1   1
      *   (add $(a (sub a 1)) $(a (sub a 2)))
  --
::::
::
    gte
  ^<  mine.[!=(->) %gte ~] 
  |>  [a=@ b=@]
  ^-  ?
  !(lth a b)
::::
::
    gth
  ^<  mine.[!=(->) %gth ~] 
  |>  [a=@ b=@]
  ^-  ?
  !(lte a b)
::::
::
    lte
  ^<  mine.[!=(->) %lte ~] 
  |>  [a=@ b=@]
  ?|(.=(a b) (lth a b))
::::
::
    lth
  ^<  mine.[!=(->) %lth ~] 
  |>  [a=@ b=@]
  ^-  ?
  ?&
    !.=(a b)
  ::
    |-
    ?:  .=(0 a)
      &
    ?:  .=(0 b)
      |
    $(a (dec a), b (dec b))
  --
::::
::
    max
  ^<  mine.[!=(->) %max ~] 
  |>  [a=@ b=@]
  ^-  @
  ?:  (gth a b)
    a
  b
::::
::
    min
  ^<  mine.[!=(->) %min ~] 
  |>  [a=@ b=@]
  ^-  @
  ?:  (lth a b)
    a
  b
::::
::
    mod
  ^<  mine.[!=(->) %mod ~] 
  |>  [a=@ b=@]
  ^-  @
  ?<  .=(0 b)
  (sub a (mul b (div a b)))
::::
::
    mul
  ^<  mine.[!=(->) %mul ~] 
  |>  [a=@ b=@]
  ^-  @
  =+  c=^-(@ 0)
  |-
  ^-  @
  ?:  .=(0 a)
    c
  $(a (dec a), c (add b c))
::::
::
    nop
  |<  a=*
  a
::::
::
    sub
  ^<  mine.[!=(->) %sub ~] 
  |>  [a=@ b=@]
  ^-  @
  ?:  .=(0 b)
    a
  $(a (dec a), b (dec b))
::
::::  
  ::  Tier 2, lists and units
::::
::
    bind
  |<  [a=*(unit) b=&*]
  ?~  a
    ~
  [~ u=(b u.a)]
::::
::
    clap
  |<  [a=*(unit) b=*(unit) c=|>(^ -<-)]
  ?~  a
    b
  ?~  b
    a
  [~ u=(c u.a u.b)]
::::
::
    drop
  |<  a=*(unit)
  ?~  a
    ~
  [i=u.a t=~]
::::
::
    flop
  |<  a=*(list)
  ^-  a
  =+  b=`a`~
  |-
  ?~  a
    b
  $(a t.a, b [i.a b])
::::
::
    levy
  |<  [a=*(list) b=|>(p=* .?(p))]
  |-
  ^-  ?
  ?~  a
    &
  ?:  (b i.a)
    $(a t.a)
  |
::::
::
    lien
  |<  [a=*(list) b=|>(p=* .?(p))]
  |-
  ^-  ?
  ?~  a
    |
  ?:  (b i.a)
    &
  $(a t.a)
::::
::
    list
  |<  a=&*
  |>  b=*
  ?-    b
      ~           ~
      [i=* t=*]   [i=(a i.b) t=$(b t.b)]
  --
::::
::
    need
  |<  a=*(unit)
  ?~  a
    !!
  u.a
::::
::
    reel
  |<  [a=*(list) b=|>([p=* q=*] q)]
  |-
  ^-  q.b
  ?~  a
    q.b
  (b i.a $(a t.a))
::::
::
    roll
  |<  [a=*(list) b=|>([p=* q=*] q)]
  |-
  ^-  q.b
  ?~  a
    q.b
  $(a t.a, b b(q (b i.a q.b)))
::::
::
    skim
  |<  [a=*(list) b=|>(p=* .?(p))]
  |-
  ^-  a
  ?~  a
    ~
  ?:((b i.a) [i.a $(a t.a)] $(a t.a))
::::
::
    skip
  |<  [a=*(list) b=|>(p=* .?(p))]
  |-
  ^-  a
  ?~  a
    ~
  ?:((b i.a) $(a t.a) [i.a $(a t.a)])
::::
::
    snag
  |<  [a=@ b=*(list)]
  |-
  ?~  b
    !!
  ^-  i.b
  ?:  .=(0 a)
    i.b
  $(b t.b, a (dec a))
::::
::
    sort
  |<  [a=*(list) b=|>([p=* q=*] .=(p q))]
  |-
  ^-  a
  ?~  a
    ~
  %+  weld
    $(a (skim a.$ |>(c=i.a (b c i.a))))
  `a.$`[i.a $(a (skim a.$ |>(c=i.a (b i.a c))))]
::::
::
    tree
  |<  a=&*
  |>  b=*
  ?-    b
      ~               ~
      [n=* l=* r=*]   [n=(a n.b) l=$(b l.b) r=$(b r.b)]
  --
::::
::
    turn
  |<  [a=*(list) b=&*]
  |-
  ?~  a
    ~
  [(b i.a) $(a t.a)]
::::
::
    unit
  |<  a=&*
  |>  b=*
  ?-    b
      ~       ~
      [~ *]   [~ u=(a +.b)]
  --
::::
::
    weld
  |<  [a=*(list) b=*(list)]
  |-
  ^-  b
  ?~  a
    b
  [i.a $(a t.a)]
::
::::
==
